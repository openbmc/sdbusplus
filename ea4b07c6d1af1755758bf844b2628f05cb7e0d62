{
  "comments": [
    {
      "key": {
        "uuid": "2ce721e6_9781d62c",
        "filename": "include/sdbusplus/message.hpp",
        "patchSetId": 2
      },
      "lineNbr": 483,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-04-21T12:00:29Z",
      "side": 1,
      "message": "What is the rationale for catching this error and turning it, effectively, into a silent issue rather than letting the top-level exception handler deal with it and/or asserting/crashing?\n\nThis seems to be the only time we do this kind of behavior from what I can tell.  We should document the rationale at least (if we keep doing it).",
      "range": {
        "startLine": 482,
        "startChar": 0,
        "endLine": 483,
        "endChar": 5
      },
      "revId": "ea4b07c6d1af1755758bf844b2628f05cb7e0d62",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7e25ac6e_ae8e6e5f",
        "filename": "include/sdbusplus/message.hpp",
        "patchSetId": 2
      },
      "lineNbr": 483,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-04-21T15:04:13Z",
      "side": 1,
      "message": "I was thinking about this commit a little more and I wonder if we need to create a promise type, which will eventually also be used for co-routines, rather than returning a simple bus::slot for async calls.  The promise would hold the return value and any exception which came from the underlying async call and when you try to get the return value it would rethrow (or the exception could be obtained from it via query).\n\nI\u0027m not suggesting that this needs to be done right now, but we should probably keep that in mind before we have too many users of this async function.",
      "parentUuid": "2ce721e6_9781d62c",
      "range": {
        "startLine": 482,
        "startChar": 0,
        "endLine": 483,
        "endChar": 5
      },
      "revId": "ea4b07c6d1af1755758bf844b2628f05cb7e0d62",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c2f4f875_b47158d4",
        "filename": "include/sdbusplus/message.hpp",
        "patchSetId": 2
      },
      "lineNbr": 483,
      "author": {
        "id": 1000188
      },
      "writtenOn": "2021-04-23T09:37:17Z",
      "side": 1,
      "message": "The rationale is similar to the event driven callback code too. I found that triggering an abort in those cases was almost always less desirable than ignoring the error, because most callbacks would end up just wrapping everything in a `try catch` block to prevent spurious aborts. In the cases it would abort, the program would end up hard to debug and failing for cases where it could limp along and still be serviceable. If you needed to do something special on error, you would have your own cleanup logic anyway. I would hope that most code is using sensible RAII, so any used resources could be cleaned up in the process.\n\nWRT to future based async. A long time ago I wrote a future / promise type intended to replace the builtin ones that use locks / atomics. It would allow the event loop to wake up the future callback and allow the user to get from it with similar semantics to std::future.\nhttps://gerrit.openbmc-project.xyz/c/openbmc/stdplus/+/22336\n\nAt the time the intended use case was for an sd_bus_call_async function\nhttps://gerrit.openbmc-project.xyz/c/openbmc/sdbusplus/+/21351\n\nBut with the coroutines features in c++20 I would need to revist how this was implemented as it doesn\u0027t really make sense with that model. I still think it would be nice to have a call_async function that more closely matches how sd_bus_call_async works under the covers for users not interested in asio / coroutines.",
      "parentUuid": "7e25ac6e_ae8e6e5f",
      "range": {
        "startLine": 482,
        "startChar": 0,
        "endLine": 483,
        "endChar": 5
      },
      "revId": "ea4b07c6d1af1755758bf844b2628f05cb7e0d62",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "86a39398_b1eefa98",
        "filename": "include/sdbusplus/message.hpp",
        "patchSetId": 2
      },
      "lineNbr": 483,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-04-30T15:54:22Z",
      "side": 1,
      "message": "\u003e I found that triggering an abort in those cases was almost always less desirable than ignoring the error, because most callbacks would end up just wrapping everything in a `try catch` block to prevent spurious aborts. In the cases it would abort, the program would end up hard to debug and failing for cases where it could limp along and still be serviceable.\n\nI don\u0027t like any silent catching and dropping of an error.  Even in this case where we\u0027re printing something to the console (maybe that ends up in the journal), nobody will look at it.  So we could go a LONG time with unseen issues before anybody deals with them.\n\nIf you print the exception, print a message, and abort, you should have everything someone needs to debug it.\n\nIf someone decides to wrap the whole call in a try-catch and drop it in their own code, that is on them.  Maybe they feel like that is a good way to deal with it.  We shouldn\u0027t make those decisions for other developers in library code though.\n\n\u003e WRT to future based async....\n\nOk.  I\u0027m planning on working on coroutine support in the near future.  We can revisit this once I have something working there.  I don\u0027t think it would be high impact to migrate people to a promise return in the future if we go that route.",
      "parentUuid": "c2f4f875_b47158d4",
      "range": {
        "startLine": 482,
        "startChar": 0,
        "endLine": 483,
        "endChar": 5
      },
      "revId": "ea4b07c6d1af1755758bf844b2628f05cb7e0d62",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2b1f5778_d8a8f617",
        "filename": "include/sdbusplus/message.hpp",
        "patchSetId": 2
      },
      "lineNbr": 484,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-04-21T12:00:29Z",
      "side": 1,
      "message": "Why fprintf?  This is C++ code.",
      "revId": "ea4b07c6d1af1755758bf844b2628f05cb7e0d62",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9a7461bc_0479ea36",
        "filename": "include/sdbusplus/message.hpp",
        "patchSetId": 2
      },
      "lineNbr": 484,
      "author": {
        "id": 1000188
      },
      "writtenOn": "2021-04-23T09:37:17Z",
      "side": 1,
      "message": "If you prefer iostreams we could do that, purely personal preference.",
      "parentUuid": "2b1f5778_d8a8f617",
      "revId": "ea4b07c6d1af1755758bf844b2628f05cb7e0d62",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "230576b9_b093ab3e",
        "filename": "include/sdbusplus/message.hpp",
        "patchSetId": 2
      },
      "lineNbr": 484,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-04-30T15:54:22Z",
      "side": 1,
      "message": "I\u0027m mostly indifferent.  We don\u0027t have other cases of this already in the code either way.  All \u0027cout\u0027 calls are in test cases or examples.  There are no [f]printf calls.\n\nThe only potential problem is that buffering can be implemented differently between C++ and C io.  We could end up with a message out the console sooner, due to use of fprintf, than the application itself due to their use of cout/cerr.",
      "parentUuid": "9a7461bc_0479ea36",
      "revId": "ea4b07c6d1af1755758bf844b2628f05cb7e0d62",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    }
  ]
}