{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b85f878d_27b13fd7",
        "filename": "include/sdbusplus/asio/connection.hpp",
        "patchSetId": 12
      },
      "lineNbr": 136,
      "author": {
        "id": 1002504
      },
      "writtenOn": "2025-10-02T15:57:31Z",
      "side": 1,
      "message": "nittest of nits:\nI tend to lean towards early exit rather than if/else, even if it means calling std::apply in more than one spot. I also I know this is an unpopular opinion, but goto isn\u0027t unreasonable for this. maybe I\u0027ll lose some credibility for that but for making sure all error paths run a function, its a decent tool when used sparingly. you can use RAII-semantics if you\u0027d like which I don\u0027t personally love for this, just because its non-obvious\n\n```\nif (ec)\n{\n    std::get\u003c0\u003e(responseData) \u003d ec;\n    std::apply(handler, responseData);\n    return;\n}\n\n// your non ec code here\n```\n\nor\n```\nif (ec)\n{\n    std::get\u003c0\u003e(responseData) \u003d ec;\n    goto apply;\n}\n\n// your non ec code here\napply:\n    std::apply(handler, responseData);\n}\n```\n\nor (I don\u0027t much care for this one, Id rather just call std::apply multiple times)\n```\ntemplate\u003ctypename F\u003e\nstruct RunOnExit {\n    RunOnExit(F\u0026\u0026 f) : f{f} {}\n    ~RunOnExit() { f(); }\n    F f;\n};\n\nRunOnExit exitHandler([\u0026responseData, \u0026handler]() { std::apply(handler, responseData); });\n\nif (ec)\n{\n   std::get\u003c0\u003e(responseData) \u003d ec;\n   return;\n}\n\n// happy-ish path\n}\n```",
      "revId": "5f943d5e60b0d693b1b8f49c8f075d4f91e19a88",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "22308e50_7ddb67c6",
        "filename": "include/sdbusplus/asio/connection.hpp",
        "patchSetId": 12
      },
      "lineNbr": 136,
      "author": {
        "id": 1002504
      },
      "writtenOn": "2025-10-02T15:58:27Z",
      "side": 1,
      "message": "feel free to just tell me \"no\" ðŸ˜Š",
      "parentUuid": "b85f878d_27b13fd7",
      "revId": "5f943d5e60b0d693b1b8f49c8f075d4f91e19a88",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "26cddedd_0093fbc2",
        "filename": "include/sdbusplus/asio/connection.hpp",
        "patchSetId": 12
      },
      "lineNbr": 136,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-10-02T16:08:46Z",
      "side": 1,
      "message": "\u003e but goto isn\u0027t unreasonable for this\n\nUnfortunately, the coding standard disagrees with you on that ðŸ˜Š\n\nhttps://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-goto\n\nthe goal with this structure was as you saw, to avoid duplicating the std::apply call.  Technically both paths are \"happy\" paths, just one involves not reading params on an error return.\n\nI appreciate the input, but I\u0027m going to go ahead and decline because one of the \"rules\" in asio is one wait should result in exactly one callback.  That\u0027s easy to verify in this flow, because there is literally only one callback.  If we duplicate, that\u0027s harder to \"see\" even if it\u0027s correct.",
      "parentUuid": "22308e50_7ddb67c6",
      "revId": "5f943d5e60b0d693b1b8f49c8f075d4f91e19a88",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}